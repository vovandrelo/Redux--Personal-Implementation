// Класс Store представляет собой механизм для создания и управления глобальным состоянием.
// Глобальное состояние - это состояние, к которому имеют доступ все компоненты проекта и при
// необходимости имеют возможность его изменять или подписываться на его изменение.
class Store {

  // State - это само глобальное состояние.
  // Реализация Store построена по аналогии с Ref-объектами, то есть при изменении ГС изменяется
  // ссылка только на state, в то время как ссылка на экземпляр класса не изменяется => не происходит
  // лишнего перерендера
  state; 

  // Для того, чтобы установить зависимость между изменяемыми данными в глобальном состоянии и
  // нуждающимися в этих данных компонентах, используется поведенческий паттерн проектирования
  // Observer, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать
  // на события, происходящие в других объектах. То есть изменение глобального состояние должно
  // повлечь перерендер только необходимых компонентов (подписчиков), а не всего приложения.

  // Объект Subscribers будет хранить информацию о компонентах-подписчиках ГС в следующем формате:
  // subscribers = { key: callback }, где:
  // - key     : уникальный идентификатор компонента-подписчика;
  // - callback: действие, при совершении которого Stor-ом компонент-подписчик получит уведомление о
  //             том, что ГС было изменено.
  subscribers = {};

  // Функция, позволяющая разбивать ГС на модули и выполнять их изменение:
  rootReducer;

  // Выполнение конструктора:
  constructor(rootReducer) {
    this.rootReducer = rootReducer;             // Создаём глобальный reducer
    this.state = this.rootReducer(this.state);  // Получаем ГС и разбиваем его на модули
  }

  // Для подписки на изменение глобального состояния реализован следующим метод:
  subscribe(key, callback) {
    this.subscribers[key] = callback;           // Создаём слушателя ГС
    this.subscribers[key](this.state);          // Высылаем ему текущие ГС
  }

  // Для отписки от изменения глобального состояния реализован следующим метод:
  unsubscribe(key) {
    delete this.subscribers[key];               // Удаляем слушателя
  }


  // Метод dispatch изменяет ГС и выполняет оповещение об изменении ГС каждого подписчика:
  dispatch(action) {
    // Изменяем ГС на основании переданного в качестве аргумента действия:
    this.state = this.rootReducer(this.state, action);

    // Функции-оповестители каждого из подписчиков перебираются:
    Object.values(this.subscribers).forEach((subscriberCallback) => {
      // Если текущее значение действительно функция, то:
      if (!!subscriberCallback && typeof subscriberCallback === "function") {
        // Выполняем функцию-оповестителя:
        subscriberCallback(this.state);
      }
    });
  }
}

// Для реализции единого источника истинности используется паттерн Singleton: при создании экземпляра
// класса будет возвращаться всегда одни и тот же объект. 

// Экспортируем экземпляр, используя паттерн Singleton, реализованный с помощью замыкания:
export const createStore = (function () {
  let storeInstance;

  return function (rootReducer) {
    if (!storeInstance) {
      storeInstance = new Store(rootReducer);
    }

    return storeInstance;
  };
})();
